# 7주차

객체 지향의 개념과 객체 지향의 4대 특성 → 객체 지향 프로그램을 작성할 도구

도구도 올바른 사용 방법이 있는 것처럼 객체 지향의 특성도 올바르게 사용하는 방법이 있음.

응집도를 높이고, 결합도는 낮추는 고전 원칙을 객체 지향의 관점에서 재정립.

# SRP: 단일 책임 원칙

Single Responsibility Principle

> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
> 

어떤 역할에 대해 한 객체가 여러 가지 일을 분담하지 않도록 하는 것.

하나의 속성이 여러 의미를 갖는 것도 단일 책임 원칙을 지키지 못하는 것.

애플리케이션의 경계를 정하고 추상화를 통해 클래스들을 선별하고 속성과 메소드를 설계할 때 고려해야 함.

# OCP: 개방 폐쇄 원칙

Open Closed Principle

> 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다.
> 

> 자신의 확장에는 열려 있고, 주변의 변화에대해서는 닫혀 있어야 한다.
> 

어떤 속성의 변화로 인해 변해선 안되는 것들이 있음. 

개방 폐쇄 원칙을 무시하면 객체 지향의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없음.

‘스프링 프레임워크’는 개방 폐쇄 원칙의 좋은 예.

# LSP: 리스코프 치환 원칙

Liskov Substitution Principle

> 서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다.
> 

객체 지향에서의 상속은 조직도나 계층도가 아닌 분류도가 되어야 함.

- 하위 분류는 상위 분류의 한 종류이다.
- 구현 분류는 인터페이스할 수 있어야 한다.

> 하위 클래스의 인스턴스는 상위형 객체 참조변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.
> 

# ISP: 인터페이스 분리 원칙

Interface Segregation Principle

> 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다.
> 

단일 책임 원칙과 인터페이스 분리 원칙은 같은 문제에 대한 두 가지 다른 해결책

→ 특별한 경우가 아니라면 단일 책임 원칙이 더 좋은 해결책

**인터페이스 최소주의 원칙**: 인터페이스를 통해 메소드를 제공할 때, 최소한의 메소드만 제공함.

추상 메소드를 이용하는 것도 하나의 방법.

# DIP: 의존 역전 원칙

Dependency Inversion Principle

> 고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.
> 

> 추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.
> 

> 자주 변경되는 구체(concrete) 클래스에 의존하지 마라.
> 

⇒ 자신보다 변하기 쉬운 것에 의존하지 마라.

상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높음.

# 정리 - 객체 지향 세계와 SOLID

객체 지향을 올바르게 프로그램에 녹여내기 위한원칙.

## SoC: 관심사의 분리

관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리하라는 것.

소스 파일의 개수가 더 많아지는 경우가 있음. → 논리를 더 잘 분할하고, 이해하기 쉽고, 개발하기 쉽고, 유지 관리 보수하기 쉬운 소스가 만들어짐.