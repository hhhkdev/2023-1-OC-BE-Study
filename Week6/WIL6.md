# WIL6

> **목표**
> 
> 추상 클래스와 인터페이스의 차이에 대해 알아봅시다. 추가적으로 static과 final 그리고 불변 객체에 대하여 알아봅시다.
> 

학습 범위: 
<aside>
💡 스프링 입문을 위한 자바 객체 지향의 원리와 이해 챕터 4
</aside>

# 필수 정리 과제

**책을 읽고 아래 키워드에 대해 정리하시오.**

1. **추상 클래스와 인터페이스**

추상 클래스는 실체를 만들어 낼 수 없는, 하나의 범주 역할을 하는 클래스. 하위 클래스에게 메소드 구현을 강제하여 여러 객체의 메소드를 일괄적으로 호출할 수 있도록 함.

인터페이스는 public 추상 메소드와 public 정적 상수만 가질 수 있음. 메소드에 public과 abstract, 속성에 public과 static, final을 붙이지 않아도 자동으로 자바가 붙여줌.

2. **static과 final 그리고 불변 객체**

스태틱은 클래스를 T메모리의 스태틱 영역에 로딩하여 클래스 생성 시에 실행되도록 함.

final 키워드가 쓰인 클래스, 변수, 메소드의 경우 각각 상속, 초기화, 재정의를 못하도록 금지시킴.

불변객체는 재할당은 가능하지만, 한 번 할당하면 내부 데이터를 변경할 수 없는 객체.

# 선택 정리 과제

**책을 읽고 다음 질문에 답하시오.**

1. **static 으로 선언한 변수의 초기화 시점에 관한 아래 문항에 답하시오.**

**(1) 일반적인 인스턴스 변수들은 객체 생성 시에 초기화된다. static 변수도 동일할 지에 대해 서술하시오.**

static 변수는 클래스가 사용되는 첫 시점에 바로 T 메모리의 스태틱 영역에 생성되므로 객체 생성 시점과 크게 관련있지는 않음.

**(2) [심화] JVM 의 동작 원리를 살펴보며, 이중에서 static 변수가 초기화되는 시점을 특정하시오.** (관련 레퍼런스를 읽어보고 답변하시면 도움이 되실 수 있습니다.)

2. **불변 객체의 장단점을 정리하시오.**

**장점** 객체에 대한 신뢰도가 높아짐. 생성자, 접근 메소드에 대한 방어 복사가 필요 없음. 멀티스레드 환경에서 동기화 처리없이 객체를 공유할 수 있음.

**단점** 메모리 누수와 새로운 객체를 계속 생성해야하기 때문에 성능 저하를 발생시킬 수 있음.

---

# 내용 정리

# `abstract` 키워드 - 추상 메소드와 추상 클래스

**추상 메소드(`Abstract`)**: 선언부는 있는데 구현부가 없는 메소드

추상 메소드를 하나라도 갖고 있는 클래스는 추상 클래스로 선언해야 함.

→ 추상 클래스는 그 자체로 객체를 만들 수 없음. 즉, `new`를 사용할 수 없음.

```java
package AbstractMethod;

public abstract class Abstract {
	abstract void General();
}
```

→ 추상 메소드는 하위 클래스에게 메소드의 구현을 강제함. **오버라이딩 강제**

→ 추상 메소드를 포함하는 클래스는 반드시 추상 클래스여야 함.

⇒ 동물이나 식물처럼 그 자체의 실체가 아닌 하나의 범주로 클래스가 필요한 경우에 유용함.

# 생성자

→ 개발자가 아무런 생성자도 만들지 않으면 자바는 인자가 없는 기본 생성자를 자동으로 만들어줌.

→ 인자가 있는 생성자를 하나라도 만든다면 자바는 기본 생성자를 만들어 주지 않음.

생성자는 개발자가 필요한 만큼 오버로딩해서 만들 수 있음. **객제 생성자 메소드**

# 클래스 생성 시의 실행 블록, `static` 블록

```java
package StaticBlock

public class StaticClass {
	static {
		/*Code*/
	}
}
```

클래스가 스태틱 영역에 배치되도록 함. 

스태틱 블록이 실행될 때는, 해상 클래스의 객체는 하나도 존재하지 않으므로 `static` 블록에서는 객체에 접근할 수 없음.

해당 패키지와 클래스가 처음 사용될 때, T메모리의 스태틱 영역에 로딩됨. → 스태틱 영역도 메모리이기 때문에 최대한 늦게 사용하고 빨리 반환하는 것이 정석임. 

(물론 스태틱 영역에 올라가면 프로그램 종료까지 메모리를 반환할 수 없음. → 그럼에도 최대한 메모리 사용을 멈춤.)

인스턴스를 여러 개 만들어도 클래스의 static 블록은 한 번만 실행됨.

# `final` 키워드

`final` 키워드가 나타날 수 있는 곳: 클래스, 변수, 메소드

- `final` 클래스: 상속을 허락하지 않겠다는 의미.
- `final` 변수: 변경 불가능한 상수 - 최초 한 번만 초기화 가능함.
- `final` 메소드: 재정의(오버라이딩) 금지.

# `instanceof` 연산자

```java
_class_instance_ instanceof _class_name_ // true or false return
```

객체 지향 설계 5원칙 중 LSP(리스코프 치환 원칙)를 어기는 코드에서 주로 나타나는 연산자.

→ 리팩터링 대상이 아닌지 점검해보아야 함.

# `package` 키워드

`package` 키워드는 네임스페이스(이름공간)를 만들어주는 역할.

네임스페이스의 필요성: 같은 이름의 멤버를 구별해주는 역할.

# `interface` 키워드과 `implements` 키워드

인터페이스 - public 추상 메소드와 public 정적 상수만 가질 수 있음.

→ 메소드에 public과 abstract, 속성에 public과 static, final을 붙이지 않아도 자동으로 자바가 붙여줌.

### 람다(Lambda)

빅데이터와 병렬성 지원을 위해 컬렉션을 강화하는 수순으로 발전.

“람다는 변후에 저장할 수 있는 로직” 

변수는 값을 저장할 수 있고, 메소드의 인자로 쓰일 수 있고, 메소드의 반환값으로 사용할 수 있음.

로직을 메소드의 인자로 쓸 수 있고, 로직을 메소드의 반환값으로 사용할 수 있음.

# `this` 키워드

객체가 자기 자신을 지칭할 때 쓰는 키워드.

- 지역 변수와 속성(객체 변수, 정적 변수)의 이름이 같은 경우 지역 변수가 우선함.
- 객체 변수와 이름이 같은 지역 변수가 있는 경우 - 객체 변수를 사용하려면 this를 접두사로 사용함.
- 정적 변수와 이름이 같은 지역 변수가 있는 경우 -  정적 변수를 사용하려면 클래스명을 접두사로 사용함.

# `super` 키워드

바로 위 상위 클래스의 인스턴스를 지칭하는 키워드.(바로 위는 접근 가능하지만 그 위는 불가능.)

(상속된 클래스에서 쓰는 this 키워드와 비슷한 느낌)

# 예비 고수를 위한 한마디

객체 멤버 메소드는 객체별로 달라지지 않음. 메소드에 사용하는 객체 멤버 속성의 값만 다를 뿐.

JVM은 객체 멤버 메소드를 스태틱 영역에 하나만 보유함.